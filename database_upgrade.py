#!/usr/bin/env python3\n\"\"\"\nDatabase Upgrade Script for School Management System\nMigrates from SQLite to PostgreSQL with enhanced features\n\"\"\"\n\nimport os\nimport sys\nimport logging\nimport sqlite3\nimport psycopg2\nfrom datetime import datetime\nfrom sqlalchemy import create_engine, text\nfrom sqlalchemy.orm import sessionmaker\nfrom flask import Flask\nfrom config_enhanced import get_config\nfrom extensions import db\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('database_upgrade.log'),\n        logging.StreamHandler(sys.stdout)\n    ]\n)\nlogger = logging.getLogger(__name__)\n\n\nclass DatabaseUpgrader:\n    \"\"\"Handles database migration from SQLite to PostgreSQL\"\"\"\n    \n    def __init__(self, sqlite_path, postgresql_url):\n        self.sqlite_path = sqlite_path\n        self.postgresql_url = postgresql_url\n        self.sqlite_conn = None\n        self.pg_engine = None\n        self.migration_stats = {\n            'tables_migrated': 0,\n            'records_migrated': 0,\n            'errors': [],\n            'start_time': None,\n            'end_time': None\n        }\n    \n    def connect_databases(self):\n        \"\"\"Establish connections to both databases\"\"\"\n        try:\n            # Connect to SQLite\n            self.sqlite_conn = sqlite3.connect(self.sqlite_path)\n            self.sqlite_conn.row_factory = sqlite3.Row\n            logger.info(f\"Connected to SQLite database: {self.sqlite_path}\")\n            \n            # Connect to PostgreSQL\n            self.pg_engine = create_engine(self.postgresql_url)\n            logger.info(f\"Connected to PostgreSQL database\")\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Failed to connect to databases: {str(e)}\")\n            return False\n    \n    def validate_sqlite_data(self):\n        \"\"\"Validate SQLite data before migration\"\"\"\n        try:\n            cursor = self.sqlite_conn.cursor()\n            \n            # Get list of tables\n            cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n            tables = [row[0] for row in cursor.fetchall()]\n            \n            logger.info(f\"Found {len(tables)} tables in SQLite database\")\n            \n            # Validate each table\n            for table in tables:\n                cursor.execute(f\"SELECT COUNT(*) FROM {table}\")\n                count = cursor.fetchone()[0]\n                logger.info(f\"Table '{table}': {count} records\")\n            \n            return True\n        except Exception as e:\n            logger.error(f\"SQLite validation failed: {str(e)}\")\n            return False\n    \n    def create_postgresql_schema(self):\n        \"\"\"Create PostgreSQL schema using Flask-Migrate\"\"\"\n        try:\n            # Create Flask app context\n            app = Flask(__name__)\n            config = get_config('production')\n            config.SQLALCHEMY_DATABASE_URI = self.postgresql_url\n            app.config.from_object(config)\n            \n            with app.app_context():\n                db.init_app(app)\n                \n                # Import all models to ensure they're registered\n                from models.user import User\n                from models.school import School\n                from models.student import Student\n                from models.teacher import Teacher\n                from models.fee import FeeStructure, Payment, StudentFeeStatus\n                from models.attendance import Attendance, AttendanceSummary\n                from models.notification import Notification, NotificationTemplate\n                from models.activity import ActivityLog, SystemMetrics\n                from models import Class, Subject\n                \n                # Create all tables\n                db.create_all()\n                logger.info(\"PostgreSQL schema created successfully\")\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Failed to create PostgreSQL schema: {str(e)}\")\n            return False\n    \n    def migrate_table_data(self, table_name, column_mapping=None):\n        \"\"\"Migrate data from SQLite table to PostgreSQL\"\"\"\n        try:\n            cursor = self.sqlite_conn.cursor()\n            \n            # Get SQLite table data\n            cursor.execute(f\"SELECT * FROM {table_name}\")\n            rows = cursor.fetchall()\n            \n            if not rows:\n                logger.info(f\"Table '{table_name}' is empty, skipping\")\n                return True\n            \n            # Get column names\n            columns = [description[0] for description in cursor.description]\n            \n            # Apply column mapping if provided\n            if column_mapping:\n                columns = [column_mapping.get(col, col) for col in columns]\n            \n            # Prepare PostgreSQL insert statement\n            placeholders = ', '.join(['%s'] * len(columns))\n            insert_sql = f\"INSERT INTO {table_name} ({', '.join(columns)}) VALUES ({placeholders})\"\n            \n            # Insert data into PostgreSQL\n            with self.pg_engine.connect() as conn:\n                for row in rows:\n                    try:\n                        conn.execute(text(insert_sql), tuple(row))\n                        self.migration_stats['records_migrated'] += 1\n                    except Exception as e:\n                        error_msg = f\"Failed to insert row in {table_name}: {str(e)}\"\n                        logger.error(error_msg)\n                        self.migration_stats['errors'].append(error_msg)\n                \n                conn.commit()\n            \n            logger.info(f\"Migrated {len(rows)} records from table '{table_name}'\")\n            self.migration_stats['tables_migrated'] += 1\n            return True\n            \n        except Exception as e:\n            error_msg = f\"Failed to migrate table '{table_name}': {str(e)}\"\n            logger.error(error_msg)\n            self.migration_stats['errors'].append(error_msg)\n            return False\n    \n    def migrate_all_data(self):\n        \"\"\"Migrate all data from SQLite to PostgreSQL\"\"\"\n        self.migration_stats['start_time'] = datetime.now()\n        \n        # Define migration order (to handle foreign key dependencies)\n        migration_order = [\n            'schools',\n            'users',\n            'classes',\n            'subjects',\n            'teachers',\n            'students',\n            'teacher_class_assignments',\n            'teacher_subject_assignments',\n            'fee_structures',\n            'student_fee_status',\n            'payments',\n            'payment_history',\n            'attendance',\n            'attendance_summary',\n            'assignments',\n            'notification_settings',\n            'notification_templates',\n            'notifications',\n            'activity_log',\n            'system_metrics'\n        ]\n        \n        # Column mappings for tables that need them\n        column_mappings = {\n            # Add any column name changes here\n            # 'old_table': {'old_column': 'new_column'}\n        }\n        \n        success_count = 0\n        for table in migration_order:\n            try:\n                # Check if table exists in SQLite\n                cursor = self.sqlite_conn.cursor()\n                cursor.execute(\n                    \"SELECT name FROM sqlite_master WHERE type='table' AND name=?\",\n                    (table,)\n                )\n                \n                if cursor.fetchone():\n                    mapping = column_mappings.get(table)\n                    if self.migrate_table_data(table, mapping):\n                        success_count += 1\n                else:\n                    logger.info(f\"Table '{table}' not found in SQLite, skipping\")\n            \n            except Exception as e:\n                logger.error(f\"Error migrating table '{table}': {str(e)}\")\n        \n        self.migration_stats['end_time'] = datetime.now()\n        \n        logger.info(f\"Migration completed: {success_count}/{len(migration_order)} tables migrated\")\n        return success_count == len([t for t in migration_order if self.table_exists(t)])\n    \n    def table_exists(self, table_name):\n        \"\"\"Check if table exists in SQLite database\"\"\"\n        cursor = self.sqlite_conn.cursor()\n        cursor.execute(\n            \"SELECT name FROM sqlite_master WHERE type='table' AND name=?\",\n            (table_name,)\n        )\n        return cursor.fetchone() is not None\n    \n    def update_sequences(self):\n        \"\"\"Update PostgreSQL sequences after data migration\"\"\"\n        try:\n            with self.pg_engine.connect() as conn:\n                # Get all tables with serial/auto-increment columns\n                result = conn.execute(text(\"\"\"\n                    SELECT schemaname, tablename, attname, typname\n                    FROM pg_attribute \n                    JOIN pg_class ON pg_attribute.attrelid = pg_class.oid \n                    JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid \n                    JOIN pg_type ON pg_attribute.atttypid = pg_type.oid \n                    WHERE pg_attribute.attnum > 0 \n                    AND NOT pg_attribute.attisdropped \n                    AND pg_type.typname IN ('int4', 'int8', 'serial', 'bigserial')\n                    AND pg_attribute.atthasdef = true\n                    AND schemaname = 'public'\n                \"\"\"))\n                \n                for row in result:\n                    schema, table, column, type_name = row\n                    if 'serial' in type_name or column == 'id':\n                        # Update sequence for this column\n                        sequence_name = f\"{table}_{column}_seq\"\n                        try:\n                            conn.execute(text(f\"\"\"\n                                SELECT setval('{sequence_name}', \n                                    COALESCE((SELECT MAX({column}) FROM {table}), 1))\n                            \"\"\"))\n                            logger.info(f\"Updated sequence for {table}.{column}\")\n                        except Exception as e:\n                            logger.warning(f\"Could not update sequence {sequence_name}: {str(e)}\")\n                \n                conn.commit()\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Failed to update sequences: {str(e)}\")\n            return False\n    \n    def verify_migration(self):\n        \"\"\"Verify that migration was successful\"\"\"\n        try:\n            sqlite_cursor = self.sqlite_conn.cursor()\n            \n            # Get table counts from SQLite\n            sqlite_cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table'\")\n            sqlite_tables = [row[0] for row in sqlite_cursor.fetchall()]\n            \n            verification_results = {}\n            \n            for table in sqlite_tables:\n                # Count records in SQLite\n                sqlite_cursor.execute(f\"SELECT COUNT(*) FROM {table}\")\n                sqlite_count = sqlite_cursor.fetchone()[0]\n                \n                # Count records in PostgreSQL\n                with self.pg_engine.connect() as conn:\n                    try:\n                        result = conn.execute(text(f\"SELECT COUNT(*) FROM {table}\"))\n                        pg_count = result.fetchone()[0]\n                        \n                        verification_results[table] = {\n                            'sqlite_count': sqlite_count,\n                            'postgresql_count': pg_count,\n                            'match': sqlite_count == pg_count\n                        }\n                        \n                        if sqlite_count == pg_count:\n                            logger.info(f\"✓ Table '{table}': {sqlite_count} records (match)\")\n                        else:\n                            logger.warning(f\"✗ Table '{table}': SQLite={sqlite_count}, PostgreSQL={pg_count}\")\n                    \n                    except Exception as e:\n                        logger.error(f\"Could not verify table '{table}': {str(e)}\")\n                        verification_results[table] = {\n                            'sqlite_count': sqlite_count,\n                            'postgresql_count': 0,\n                            'match': False,\n                            'error': str(e)\n                        }\n            \n            return verification_results\n        \n        except Exception as e:\n            logger.error(f\"Verification failed: {str(e)}\")\n            return {}\n    \n    def create_backup(self):\n        \"\"\"Create backup of SQLite database before migration\"\"\"\n        try:\n            backup_path = f\"{self.sqlite_path}.backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n            \n            # Copy SQLite file\n            import shutil\n            shutil.copy2(self.sqlite_path, backup_path)\n            \n            logger.info(f\"Created backup: {backup_path}\")\n            return backup_path\n        \n        except Exception as e:\n            logger.error(f\"Failed to create backup: {str(e)}\")\n            return None\n    \n    def run_migration(self):\n        \"\"\"Run complete migration process\"\"\"\n        logger.info(\"Starting database migration from SQLite to PostgreSQL\")\n        \n        # Step 1: Create backup\n        backup_path = self.create_backup()\n        if not backup_path:\n            logger.error(\"Failed to create backup, aborting migration\")\n            return False\n        \n        # Step 2: Connect to databases\n        if not self.connect_databases():\n            return False\n        \n        # Step 3: Validate SQLite data\n        if not self.validate_sqlite_data():\n            return False\n        \n        # Step 4: Create PostgreSQL schema\n        if not self.create_postgresql_schema():\n            return False\n        \n        # Step 5: Migrate data\n        if not self.migrate_all_data():\n            logger.error(\"Data migration failed\")\n            return False\n        \n        # Step 6: Update sequences\n        if not self.update_sequences():\n            logger.warning(\"Failed to update sequences, manual intervention may be required\")\n        \n        # Step 7: Verify migration\n        verification_results = self.verify_migration()\n        \n        # Step 8: Print summary\n        self.print_migration_summary(verification_results)\n        \n        logger.info(\"Database migration completed successfully\")\n        return True\n    \n    def print_migration_summary(self, verification_results):\n        \"\"\"Print migration summary\"\"\"\n        duration = self.migration_stats['end_time'] - self.migration_stats['start_time']\n        \n        print(\"\\n\" + \"=\"*60)\n        print(\"DATABASE MIGRATION SUMMARY\")\n        print(\"=\"*60)\n        print(f\"Start Time: {self.migration_stats['start_time']}\")\n        print(f\"End Time: {self.migration_stats['end_time']}\")\n        print(f\"Duration: {duration}\")\n        print(f\"Tables Migrated: {self.migration_stats['tables_migrated']}\")\n        print(f\"Records Migrated: {self.migration_stats['records_migrated']}\")\n        print(f\"Errors: {len(self.migration_stats['errors'])}\")\n        \n        if verification_results:\n            print(\"\\nVERIFICATION RESULTS:\")\n            for table, result in verification_results.items():\n                status = \"✓\" if result['match'] else \"✗\"\n                print(f\"{status} {table}: {result['sqlite_count']} → {result['postgresql_count']}\")\n        \n        if self.migration_stats['errors']:\n            print(\"\\nERRORS:\")\n            for error in self.migration_stats['errors']:\n                print(f\"- {error}\")\n        \n        print(\"=\"*60)\n    \n    def close_connections(self):\n        \"\"\"Close database connections\"\"\"\n        if self.sqlite_conn:\n            self.sqlite_conn.close()\n        if self.pg_engine:\n            self.pg_engine.dispose()\n\n\ndef main():\n    \"\"\"Main migration function\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='Migrate SQLite database to PostgreSQL')\n    parser.add_argument('--sqlite-path', required=True, help='Path to SQLite database file')\n    parser.add_argument('--postgresql-url', required=True, help='PostgreSQL connection URL')\n    parser.add_argument('--dry-run', action='store_true', help='Perform dry run without actual migration')\n    \n    args = parser.parse_args()\n    \n    if not os.path.exists(args.sqlite_path):\n        logger.error(f\"SQLite database file not found: {args.sqlite_path}\")\n        return False\n    \n    if args.dry_run:\n        logger.info(\"DRY RUN MODE - No actual migration will be performed\")\n        # TODO: Implement dry run logic\n        return True\n    \n    # Run migration\n    upgrader = DatabaseUpgrader(args.sqlite_path, args.postgresql_url)\n    \n    try:\n        success = upgrader.run_migration()\n        return success\n    finally:\n        upgrader.close_connections()\n\n\nif __name__ == '__main__':\n    success = main()\n    sys.exit(0 if success else 1)\n